{"version":3,"file":"index.js","sources":["../lib/constants.js","../index.js"],"sourcesContent":["// Events\nexport const CROPTAG_READY = 'croptag.ready';\n// Mouse events\nexport const MOUSE_DOWN = 'mousedown';\nexport const MOUSE_MOVE = 'mousemove';\nexport const MOUSE_UP = 'mouseup';\n// Classes\nexport const CROPTAG_ERROR = 'crop-tag-error';\nexport const CROPTAG_MASK = 'crop-tag-mask';\nexport const CROPTAG_WRAP = 'crop-tag-wrap';\nexport const CROPTAG_TAG = 'crop-tag-element';\nexport const CROPTAG_DOT = 'crop-tag-dot';\nexport const CROPTAG_EDGE = 'crop-tag-edge';","import { CROPTAG_READY, CROPTAG_ERROR, CROPTAG_WRAP, CROPTAG_MASK, MOUSE_DOWN, CROPTAG_TAG, CROPTAG_DOT, CROPTAG_EDGE, MOUSE_MOVE, MOUSE_UP } from './lib/constants';\n\n/**\n * Creates and return a DOM element\n * @private\n * @param {string} el Element type\n * @param {object} attributes Element attributes\n * @param {string} html HTML string\n * @returns {Node}\n */\nfunction _createElement(el, attributes = {}, html = '') {\n    const tag = document.createElement(el);\n    Object.keys(attributes).forEach((attr) => {\n        tag.setAttribute(attr, attributes[attr]);\n    });\n    if (html) {\n        tag.innerHTML = html;\n    }\n    return tag;\n}\n\n/**\n * Wraps images for drawing tags\n * @private\n * @param {Node[]} imageList Element list\n */\nfunction _wrapAndMask(imageList) {\n    imageList.forEach(img => {\n        const wrapper = _createElement('div', {\n            style: 'position: relative; width: 100%; height: 100%;',\n            class: CROPTAG_WRAP\n        });\n        img.parentNode.insertBefore(wrapper, img);\n        wrapper.appendChild(img);\n        wrapper.appendChild(_createElement('div', {\n            style: 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;',\n            class: CROPTAG_MASK\n        }));\n    });\n}\n\n/**\n * Returns a promise to ensure the tags are created only when image is available\n * @param {Node[]} imageList Image list\n */\nfunction _resolveImageData(imageList) {\n    return Promise.all(imageList.map(img => new Promise((resolve) => {\n        if (img.complete) {\n            const hasErrors = img.naturalWidth === 0 || img.naturalHeight === 0;\n            if (hasErrors) {\n                img.classList.add(CROPTAG_ERROR);\n            }\n            resolve();\n            this.originalImages.push({\n                img,\n                src: img.src,\n                width: img.naturalWidth,\n                height: img.naturalHeight,\n                hasErrors\n            });\n        } else {\n            img.onload = () => {\n                resolve();\n                this.originalImages.push({\n                    img,\n                    src: img.src,\n                    width: img.naturalWidth,\n                    height: img.naturalHeight,\n                    hasErrors: false\n                });\n            };\n            img.onerror = () => {\n                img.classList.add(CROPTAG_ERROR);\n                resolve();\n                this.originalImages.push({\n                    img,\n                    src: img.src,\n                    width: img.naturalWidth,\n                    height: img.naturalHeight,\n                    hasErrors: true\n                });\n            }\n        }\n    }))).then(() => this.originalImages);\n}\n\nfunction _createMask(image, imageAlt, target) {\n    const imageList = (\n        image instanceof NodeList\n        || image instanceof HTMLCollection\n    )\n        ? [...image] : (\n            image instanceof Node\n        )\n            ? [image] : [];\n    if (imageList.length === 0) {\n        if (typeof image === 'string') {\n            // Possibly URL\n            if (target instanceof Node) {\n                const img = _createElement('img', {\n                    src: image,\n                    alt: (imageAlt || 'CropTag image')\n                });\n                target.appendChild(img);\n                imageList.push(target);\n            } else {\n                throw new TypeError('Target node is unavailable');\n            }\n        } else {\n            throw new TypeError('Image should be a valid DOM element or URL');\n        }\n    }\n    _wrapAndMask(imageList);\n    return imageList;\n}\n\nfunction _validateSchema(dots, defaultDots) {\n    let isValid = true;\n    Object.keys(dots).forEach(dot => {\n        if (!(dot in defaultDots)) {\n            isValid = false;\n        }\n    });\n    if (!isValid) {\n        throw new Error(`Input dots does not match current schema. Accepted values are ${Object.keys(defaultDots).join(', ')}`);\n    }\n    return isValid;\n}\n\nfunction _insertSquare({ e, dots, edges, drag, defaultDots }) {\n    const rect = this.getBoundingClientRect();\n    const left = e.clientX - rect.left;\n    const top = e.clientY - rect.top;\n    const square = _createElement('div', {\n        class: `${CROPTAG_TAG}${drag ? ` ${CROPTAG_TAG}--drag` : ''}`,\n        style: `position: absolute; top: ${top}px; left: ${left}px;`\n    });\n    if (dots) {\n        let availableDots = defaultDots;\n        if (typeof dots === 'object' && _validateSchema(dots, defaultDots)) {\n            availableDots = dots;\n        }\n        Object.keys(availableDots).forEach(dot => {\n            square.appendChild(_createElement('div', {\n                class: `${CROPTAG_DOT} ${CROPTAG_DOT}--${availableDots[dot]}`\n            }));\n        });\n    }\n    if (edges && drag) {\n        ['top', 'left', 'bottom', 'right'].forEach(edge => {\n            square.appendChild(_createElement('div', {\n                class: `${CROPTAG_EDGE} ${CROPTAG_EDGE}--drag ${CROPTAG_EDGE}--${edge}`\n            }));\n        });\n    }\n    this.appendChild(square);\n    return square;\n}\n\nfunction _bindEvents() {\n    const { dots, edges, drag } = this.config;\n    const { defaultDots } = this;\n    document.addEventListener(MOUSE_DOWN, (e) => {\n        let currentTarget = e.target;\n        if (edges && currentTarget.classList.contains(CROPTAG_TAG)) {\n            currentTarget = currentTarget.parentNode;\n        }\n        if (currentTarget.classList.contains(CROPTAG_MASK)) {\n            const square = _insertSquare.apply(currentTarget, [{ e, dots, edges, drag, defaultDots }]);\n            const x1 = e.clientX;\n            const y1 = e.clientY;\n            const initialLeft = square.style.left;\n            const initialTop = square.style.top;\n            const ctRect = currentTarget.getBoundingClientRect();\n            this.drawHandler = function (e) {\n                const x2 = e.clientX;\n                const y2 = e.clientY;\n                const width = x2 - x1;\n                const height = y2 - y1;\n                const sqRect = square.getBoundingClientRect();\n                const maxAttainableWidth = ctRect.width - sqRect.left;\n                const maxAttainableHeight = ctRect.height - sqRect.top;\n                console.log(maxAttainableWidth, maxAttainableHeight);\n                square.style.width = `${(Math.abs((width < maxAttainableWidth ? width : maxAttainableWidth))) / ctRect.width * 100}%`;\n                square.style.height = `${(Math.abs((height < maxAttainableHeight ? height : maxAttainableHeight))) / ctRect.height * 100}%`;\n                const computedLeft = (parseFloat(initialLeft) + width) / ctRect.width * 100;\n                const computedTop = (parseFloat(initialTop) + height) / ctRect.height * 100;\n                const effectiveLeft = computedLeft > 0 ? computedLeft : 0;\n                const effectiveTop = computedTop > 0 ? computedTop : 0;\n                if (width < 0) {\n                    square.style.left = `${effectiveLeft}%`;\n                }\n                if (height < 0) {\n                    square.style.top = `${effectiveTop}%`\n                }\n            }\n            document.addEventListener(MOUSE_MOVE, this.drawHandler);\n        }\n    });\n    document.addEventListener(MOUSE_UP, () => {\n        document.removeEventListener(MOUSE_MOVE, this.drawHandler);\n        this.drawHandler = null;\n    });\n}\n\nexport default class CropTag {\n    constructor(config) {\n        config = config || {};\n        this.config = Object.assign({\n            dots: true, // Enables resize dots\n            edges: true, // Enables edges for drag\n            drag: true, // Enables drag via edges\n            focussedTags: false, // Enables focus and blur effect to get details of only focussed tag\n            image: null, // Image URL or reference\n            imageAlt: null,\n            target: null // Image target to be used if image URL is passed\n        }, config);\n        // Mask image\n        const { image, imageAlt, target } = this.config;\n        _resolveImageData.apply(this, [_createMask(image, imageAlt, target)]).then((imageData) => {\n            const onReady = new CustomEvent(CROPTAG_READY, {\n                bubbles: true,\n                cancelable: true,\n                detail: {\n                    payload: imageData\n                }\n            });\n            imageData.forEach(({ img }) => {\n                img.dispatchEvent(onReady);\n            });\n            _bindEvents.apply(this);\n        });\n    }\n    originalImages = [];\n    defaultDots = {\n        TL: 'top-left',\n        T: 'top',\n        TR: 'top-right',\n        R: 'right',\n        BR: 'bottom-right',\n        B: 'bottom',\n        BL: 'bottom-left',\n        L: 'left'\n    };\n    getAll() {\n        // TODO: Returns all tags\n    }\n    get(index) {\n        //TODO: Returns focussed tag if focussedTags is enabled, else returns tag info based on created index\n    }\n}"],"names":["CROPTAG_READY","MOUSE_DOWN","MOUSE_MOVE","MOUSE_UP","CROPTAG_ERROR","CROPTAG_MASK","CROPTAG_WRAP","CROPTAG_TAG","CROPTAG_DOT","CROPTAG_EDGE","_createElement","el","attributes","html","tag","document","createElement","Object","keys","forEach","attr","setAttribute","innerHTML","_createMask","image","imageAlt","target","imageList","NodeList","HTMLCollection","Node","length","TypeError","img","src","alt","appendChild","push","wrapper","style","parentNode","insertBefore","_wrapAndMask","_insertSquare","e","dots","edges","drag","defaultDots","rect","this","getBoundingClientRect","left","clientX","top","clientY","square","availableDots","_typeof","isValid","dot","Error","join","_validateSchema","edge","config","TL","T","TR","R","BR","B","BL","L","assign","focussedTags","Promise","all","map","resolve","complete","hasErrors","naturalWidth","naturalHeight","classList","add","_this","originalImages","width","height","onload","onerror","then","apply","imageData","onReady","CustomEvent","bubbles","cancelable","detail","payload","dispatchEvent","addEventListener","currentTarget","contains","x1","y1","initialLeft","initialTop","ctRect","_this2","drawHandler","x2","y2","sqRect","maxAttainableWidth","maxAttainableHeight","console","log","Math","abs","computedLeft","parseFloat","computedTop","effectiveLeft","effectiveTop","removeEventListener","_this3","index"],"mappings":"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"}